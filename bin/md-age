#!/usr/bin/env bash
#
# md-age - age encryption for markdown files with YAML frontmatter
#
# Encrypts/decrypts markdown files while preserving frontmatter.
# Recipients are read from frontmatter age-recipients field by default.
#
# SPDX-License-Identifier: AGPL-3.0-or-later

set -euo pipefail

# Use MD_AGE_COMMAND env var or default to 'age'
age_cmd="${MD_AGE_COMMAND:-age}"

usage() {
    cat <<'EOF'
Usage: md-age [-e|-d] [-r RECIPIENT]... [-i IDENTITY]... [-o OUTPUT] [FILE]

Encrypt or decrypt markdown files with age, preserving YAML frontmatter.

Modes:
  -e            Encrypt (default)
  -d            Decrypt

Options:
  -r RECIPIENT  Recipient for encryption (age public key, SSH key, or file path)
                If not specified, uses age-recipients from frontmatter
  -R FILE       Recipients file (passed to age as -R)
  -i IDENTITY   Identity file for decryption (passed to age as -i)
  -o OUTPUT     Write to OUTPUT instead of stdout
  -h            Show this help

Examples:
  # Encrypt using recipients from frontmatter
  md-age -e notes.md > notes.md.enc

  # Encrypt with explicit recipient
  md-age -e -r age1... plaintext.md > encrypted.md

  # Decrypt
  md-age -d -i ~/.age/key.txt encrypted.md > decrypted.md

  # In-place edit (decrypt, edit, re-encrypt)
  md-age -d -i key.txt file.md | vim - | md-age -e -o file.md

Git integration:
  md-age git init              Set up filters in current repo
  md-age git config add -i     Add identity for decryption
  md-age git config list       Show configured identities
  md-age git config remove -i  Remove identity

  Run 'md-age git --help' for more details.

Frontmatter format:
  ---
  age-encrypt: yes
  age-recipients:
    - age1...              # age public key
    - ssh-ed25519...       # SSH public key
    - git:path/to/file     # recipients file relative to git root
    - ~/.age/file          # recipients file (absolute or ~)
    - ../relative/file     # recipients file relative to this file
  ---
EOF
    exit "${1:-0}"
}

git_usage() {
    cat <<'EOF'
Usage: md-age git <command> [options]

git subcommands for transparent encryption:
  init              Set up filters in current repo
  config            Manage identity configuration
  rekey [files...]  Re-encrypt files (use after adding recipients)
  clean             Encrypt filter (for git)
  smudge            Decrypt filter (for git)

Run 'md-age git <command> --help' for command-specific help.
EOF
    exit "${1:-0}"
}

# Compute cache key for content
# Key = SHA256(sorted_recipients || NUL || body)
compute_cache_key() {
    local recipients="$1"
    local body="$2"

    # Sort recipients for consistency
    local sorted_recipients
    sorted_recipients=$(echo "$recipients" | sort)

    # Compute hash
    printf '%s\0%s' "$sorted_recipients" "$body" | shasum -a 256 | cut -d' ' -f1
}

# Get cache directory (creates if needed)
get_cache_dir() {
    # Use --git-common-dir so worktrees share the cache with the main repo.
    # This prevents age's non-deterministic encryption from making every
    # encrypted file appear modified in new worktrees.
    local git_dir
    git_dir=$(git rev-parse --git-common-dir 2>/dev/null) || return 1
    local cache_dir="$git_dir/md-age/hashes"
    mkdir -p "$cache_dir"
    echo "$cache_dir"
}

# Get cached ciphertext for key, returns 1 if not found
get_cached() {
    local key="$1"
    local cache_dir
    cache_dir=$(get_cache_dir) || return 1

    local prefix="${key:0:2}"
    local cache_file="$cache_dir/$prefix/$key"

    if [[ -f "$cache_file" ]]; then
        cat "$cache_file"
        return 0
    fi
    return 1
}

# Store ciphertext in cache
set_cached() {
    local key="$1"
    local ciphertext="$2"
    local cache_dir
    cache_dir=$(get_cache_dir) || return 1

    local prefix="${key:0:2}"
    mkdir -p "$cache_dir/$prefix"
    local cache_file="$cache_dir/$prefix/$key"

    printf '%s' "$ciphertext" > "$cache_file"
}

git_init() {
    if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git init

Set up md-age filter configuration in the current git repository.
Adds filter and diff settings to .git/config and .gitattributes.
EOF
        exit 0
    fi

    # Check we're in a git repo
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    # Get absolute path to this script
    local md_age_path
    md_age_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Find age command
    local age_path
    age_path=$(command -v age 2>/dev/null) || die "age not found in PATH"

    # Build command prefix with absolute paths
    local cmd_prefix="MD_AGE_COMMAND=$age_path $md_age_path"

    # Set up filter
    git config filter.md-age.clean "$cmd_prefix git clean %f"
    git config filter.md-age.smudge "$cmd_prefix git smudge %f"
    git config filter.md-age.required true

    # Set up diff (textconv receives filename as $1, not via %f)
    git config diff.md-age.textconv "sh -c 'cat \"\$1\" | $cmd_prefix git smudge \"\$1\"' --"

    echo "md-age: filter configured in .git/config"
    echo "  md-age: $md_age_path"
    echo "  age:    $age_path"

    # Add to .gitattributes if not already present
    local gitattr_line="*.md filter=md-age diff=md-age"
    local repo_root
    repo_root=$(git rev-parse --show-toplevel)
    local gitattr="$repo_root/.gitattributes"

    if [[ -f "$gitattr" ]] && grep -qF "$gitattr_line" "$gitattr"; then
        echo "md-age: .gitattributes already configured"
    else
        echo "$gitattr_line" >> "$gitattr"
        echo "md-age: added '$gitattr_line' to .gitattributes"
    fi
}
git_config() {
    local cmd="${1:-}"

    case "$cmd" in
        -h|--help|"")
            cat <<'EOF'
Usage: md-age git config <command>

Commands:
  add -i <path>     Add an identity file
  list              List configured identities
  remove -i <path>  Remove an identity file

Identities are stored in .git/config (not version controlled).

Use cmd: prefix to run a command that outputs the identity:
  md-age git config add -i "cmd:pass age/my-key"
EOF
            exit 0
            ;;
        add)
            shift
            git_config_add "$@"
            ;;
        list)
            git_config_list
            ;;
        remove)
            shift
            git_config_remove "$@"
            ;;
        *)
            die "unknown config command: $cmd"
            ;;
    esac
}

git_config_add() {
    local identity=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i) identity="$2"; shift 2 ;;
            *) die "unknown option: $1" ;;
        esac
    done

    [[ -n "$identity" ]] || die "no identity specified (-i)"
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    # Expand ~ but store the expanded path
    local expanded="${identity/#\~/$HOME}"

    # Check if already added
    if git config --get-all md-age.config.identity 2>/dev/null | grep -qF "$expanded"; then
        echo "md-age: identity already configured: $expanded"
        return 0
    fi

    git config --add md-age.config.identity "$expanded"
    echo "md-age: added identity: $expanded"
}

git_config_list() {
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    local identities
    identities=$(git config --get-all md-age.config.identity 2>/dev/null || true)

    if [[ -z "$identities" ]]; then
        echo "md-age: no identities configured"
        echo "md-age: use 'md-age git config add -i <path>' to add one"
        return 0
    fi

    echo "Identities:"
    while IFS= read -r id; do
        echo "  $id"
    done <<< "$identities"
}

git_config_remove() {
    local identity=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i) identity="$2"; shift 2 ;;
            *) die "unknown option: $1" ;;
        esac
    done

    [[ -n "$identity" ]] || die "no identity specified (-i)"
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    local expanded="${identity/#\~/$HOME}"

    if git config --unset md-age.config.identity "$expanded" 2>/dev/null; then
        echo "md-age: removed identity: $expanded"
    else
        die "identity not found: $expanded"
    fi
}

git_rekey() {
    if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git rekey [files...]

Re-encrypt md-age files with current recipients. Use this after adding
or removing recipients from frontmatter or recipient files.

If no files specified, finds and rekeys all md-age files in the repo.

Options:
  -n, --dry-run    Show what would be rekeyed without making changes
  -v, --verbose    Show detailed progress

This command:
  1. Clears cached ciphertext for specified files
  2. Forces git to re-stage files through the clean filter
  3. Verifies new ciphertext has expected recipient count
EOF
        exit 0
    fi

    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    local dry_run=0
    local verbose=0
    local files=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--dry-run) dry_run=1; shift ;;
            -v|--verbose) verbose=1; shift ;;
            -*) die "unknown option: $1" ;;
            *) files+=("$1"); shift ;;
        esac
    done

    local repo_root
    repo_root=$(git rev-parse --show-toplevel)

    # If no files specified, find all md-age files
    if [[ ${#files[@]} -eq 0 ]]; then
        while IFS= read -r -d '' file; do
            # Check if file has age-encrypt: yes in frontmatter
            if head -20 "$file" 2>/dev/null | should_encrypt; then
                files+=("$file")
            fi
        done < <(find "$repo_root" -name '*.md' -type f -print0 2>/dev/null)
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "md-age: no md-age files found"
        exit 0
    fi

    local cache_dir
    cache_dir=$(get_cache_dir 2>/dev/null) || cache_dir=""

    local rekeyed=0
    local errors=0
    local file

    for file in "${files[@]}"; do
        # Make path relative to repo root for display
        local rel_path="${file#$repo_root/}"

        # Verify file exists and is tracked
        if [[ ! -f "$file" ]]; then
            echo "md-age: skipping (not found): $rel_path" >&2
            continue
        fi

        # Check if file has age-encrypt: yes
        if ! head -20 "$file" 2>/dev/null | should_encrypt; then
            [[ $verbose -eq 1 ]] && echo "md-age: skipping (not md-age): $rel_path"
            continue
        fi

        if [[ $dry_run -eq 1 ]]; then
            echo "md-age: would rekey: $rel_path"
            rekeyed=$((rekeyed + 1))
            continue
        fi

        [[ $verbose -eq 1 ]] && echo "md-age: rekeying: $rel_path"

        # Save old staged content to detect if re-encryption actually happened
        local old_staged=""
        old_staged=$(git show ":$rel_path" 2>/dev/null) || true

        # Clear cache for this file's content
        if [[ -n "$cache_dir" ]] && [[ -d "$cache_dir" ]]; then
            # Can't easily find exact cache entry, so we'll let it miss
            # The cache key includes resolved recipients, so changing
            # recipient file content already invalidates the cache
            :
        fi

        # Force re-stage: remove from index then re-add
        # This triggers the clean filter with fresh encryption
        if ! git rm --cached -q "$file" 2>/dev/null; then
            # File might not be tracked yet
            :
        fi

        if ! git add "$file" 2>/dev/null; then
            echo "md-age: ERROR: failed to re-stage: $rel_path" >&2
            errors=$((errors + 1))
            continue
        fi

        # Verify the staged content is properly encrypted
        local staged_content
        staged_content=$(git show ":$rel_path" 2>/dev/null) || {
            echo "md-age: ERROR: failed to read staged content: $rel_path" >&2
            errors=$((errors + 1))
            continue
        }

        # Check if content actually changed
        # If unchanged AND working copy is still encrypted, we couldn't decrypt
        if [[ -n "$old_staged" ]] && [[ "$staged_content" == "$old_staged" ]]; then
            # Check if working copy body is encrypted (couldn't decrypt)
            local wc_body
            wc_body=$(sed -n '/^---$/,/^---$/d; p' "$file" | head -5)
            local wc_trimmed="${wc_body#"${wc_body%%[![:space:]]*}"}"
            if [[ "$wc_trimmed" == "-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
                echo "md-age: ERROR: could not decrypt (missing identity?): $rel_path" >&2
                errors=$((errors + 1))
                # Restore the old staged content
                git add "$file" 2>/dev/null || true
                continue
            fi
            # Working copy is decrypted, content just hasn't changed - that's OK
            [[ $verbose -eq 1 ]] && echo "md-age: OK (unchanged): $rel_path"
            rekeyed=$((rekeyed + 1))
            continue
        fi

        # Check it starts with frontmatter + AGE block (not plaintext body)
        if echo "$staged_content" | grep -q '^-----BEGIN AGE ENCRYPTED FILE-----'; then
            rekeyed=$((rekeyed + 1))
            [[ $verbose -eq 1 ]] && echo "md-age: OK: $rel_path"
        else
            # Check if body after frontmatter is encrypted
            local body_start
            body_start=$(echo "$staged_content" | grep -n '^---$' | tail -1 | cut -d: -f1)
            if [[ -n "$body_start" ]]; then
                local body
                body=$(echo "$staged_content" | tail -n +$((body_start + 1)))
                local trimmed="${body#"${body%%[![:space:]]*}"}"
                if [[ "$trimmed" == "-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
                    rekeyed=$((rekeyed + 1))
                    [[ $verbose -eq 1 ]] && echo "md-age: OK: $rel_path"
                else
                    echo "md-age: ERROR: staged content not encrypted: $rel_path" >&2
                    errors=$((errors + 1))
                fi
            else
                echo "md-age: ERROR: no frontmatter in staged content: $rel_path" >&2
                errors=$((errors + 1))
            fi
        fi
    done

    echo "md-age: rekeyed $rekeyed file(s)"
    [[ $errors -gt 0 ]] && echo "md-age: $errors error(s)" >&2
    [[ $errors -gt 0 ]] && exit 1
    exit 0
}

git_clean() {
    local filename="${1:-}"

    if [[ "$filename" == "-h" ]] || [[ "$filename" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git clean <filename>

Git clean filter - encrypts md-age files on stage.
Reads from stdin, writes to stdout.
Non-md-age files pass through unchanged.
EOF
        exit 0
    fi

    # Read all stdin, preserving trailing newlines
    # (bash command substitution strips trailing newlines)
    local content
    content=$(cat; printf x)
    content="${content%x}"

    # Parse frontmatter
    if ! parse_frontmatter "$content"; then
        # No frontmatter - pass through
        printf '%s' "$content"
        return 0
    fi

    local frontmatter="$FRONTMATTER"
    local body="$BODY"
    body="${body%$'\n'}"  # Remove trailing newline

    # Check if this is an md-age file
    if ! echo "$frontmatter" | should_encrypt; then
        # Not an md-age file - pass through
        printf '%s' "$content"
        return 0
    fi

    # Check if body is already encrypted (must START with marker, not just contain it)
    local trimmed_body="${body#"${body%%[![:space:]]*}"}"  # strip leading whitespace
    if [[ "$trimmed_body" == "-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
        # Already encrypted - decrypt first so we can re-encrypt
        # This handles the case where recipients changed in frontmatter
        local identities
        identities=$(git config --get-all md-age.config.identity 2>/dev/null || true)

        if [[ -z "$identities" ]]; then
            # No identity to decrypt - pass through as-is
            # (can't re-encrypt without decrypting first)
            printf '%s' "$content"
            return 0
        fi

        # Build identity args
        local id_args=""
        while IFS= read -r id; do
            [[ -z "$id" ]] && continue
            if [[ "$id" == cmd:* ]]; then
                local cmd="${id#cmd:}"
                id_args="$id_args -i <($cmd)"
            else
                id_args="$id_args -i $id"
            fi
        done <<< "$identities"

        # Decrypt the body
        local decrypted
        if decrypted=$(eval "printf '%s' \"\$body\" | $age_cmd -d $id_args" 2>/dev/null); then
            body="$decrypted"
        else
            # Decryption failed - pass through unchanged
            # (maybe encrypted for different recipient we don't have)
            printf '%s' "$content"
            return 0
        fi
    elif [[ "$body" == *"-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
        # Body contains AGE marker but doesn't start with it - mixed content error
        echo "md-age: clean: ERROR: $filename has mixed plaintext and encrypted content" >&2
        echo "md-age: clean: This usually means the file was corrupted. Fix manually." >&2
        exit 1
    fi

    # Extract recipients
    local recipients
    recipients=$(echo "$frontmatter" | extract_recipients)

    if [[ -z "$recipients" ]]; then
        echo "md-age: clean: no recipients in frontmatter for $filename" >&2
        exit 1
    fi

    # Resolve recipients to actual keys (needed for both cache key and encryption)
    local age_args
    local file_dir
    file_dir=$(dirname "$filename")
    age_args=$(build_recipient_args "$recipients" "$file_dir")

    # Compute cache key using RESOLVED recipients (not frontmatter paths)
    # This ensures cache invalidates when recipient file contents change
    local cache_key
    cache_key=$(compute_cache_key "$age_args" "$body")

    # Check cache
    local encrypted
    if encrypted=$(get_cached "$cache_key" 2>/dev/null); then
        # Cache hit - use cached ciphertext
        printf '%s' "$frontmatter"
        printf '%s\n' "$encrypted"
        return 0
    fi

    # Cache miss - encrypt

    encrypted=$(printf '%s' "$body" | $age_cmd -e -a $age_args) || {
        echo "md-age: clean: encryption failed for $filename" >&2
        exit 1
    }

    # Store in cache
    set_cached "$cache_key" "$encrypted" 2>/dev/null || true

    # Output frontmatter + encrypted body
    printf '%s' "$frontmatter"
    printf '%s\n' "$encrypted"
}
git_smudge() {
    local filename="${1:-}"

    if [[ "$filename" == "-h" ]] || [[ "$filename" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git smudge <filename>

Git smudge filter - decrypts md-age files on checkout.
Reads from stdin, writes to stdout.
Non-md-age files pass through unchanged.
If no identity configured, encrypted files pass through unchanged.
EOF
        exit 0
    fi

    # Always read from stdin (git filter provides content via stdin)
    # Preserve trailing newlines (bash command substitution strips them)
    local content
    content=$(cat; printf x)
    content="${content%x}"

    # Parse frontmatter
    if ! parse_frontmatter "$content"; then
        # No frontmatter - pass through
        printf '%s' "$content"
        return 0
    fi

    local frontmatter="$FRONTMATTER"
    local body="$BODY"
    body="${body%$'\n'}"

    # Check if this is an md-age file
    if ! echo "$frontmatter" | should_encrypt; then
        printf '%s' "$content"
        return 0
    fi

    # Check if body is encrypted (must START with marker)
    local trimmed_body="${body#"${body%%[![:space:]]*}"}"  # strip leading whitespace
    if [[ "$trimmed_body" != "-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
        # Not encrypted - pass through (new file perhaps)
        # But warn if it contains AGE marker somewhere (corrupted state)
        if [[ "$body" == *"-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
            echo "md-age: smudge: WARNING: $filename has mixed plaintext and encrypted content" >&2
        fi
        printf '%s' "$content"
        return 0
    fi

    # Get identities from git config
    local identities
    identities=$(git config --get-all md-age.config.identity 2>/dev/null || true)

    if [[ -z "$identities" ]]; then
        # No identity - pass through encrypted
        printf '%s' "$content"
        return 0
    fi

    # Build identity args
    # Supports cmd: prefix for shell commands (e.g., "cmd:pass age/key")
    local id_args=""
    while IFS= read -r id; do
        [[ -z "$id" ]] && continue
        if [[ "$id" == cmd:* ]]; then
            # Extract command and use process substitution
            local cmd="${id#cmd:}"
            id_args="$id_args -i <($cmd)"
        else
            id_args="$id_args -i $id"
        fi
    done <<< "$identities"

    # Try to decrypt (use eval to expand process substitutions from cmd: identities)
    local decrypted
    if decrypted=$(eval "printf '%s' \"\$body\" | $age_cmd -d $id_args" 2>/dev/null); then
        # Success - output frontmatter + decrypted
        printf '%s' "$frontmatter"
        printf '%s\n' "$decrypted"
    else
        # Decrypt failed - pass through encrypted
        printf '%s' "$content"
    fi
}

die() {
    echo "md-age: $*" >&2
    exit 1
}

# Normalize a YAML value (strip quotes and whitespace, lowercase)
normalize_yaml_value() {
    local v="$1"
    # Trim whitespace
    v="${v#"${v%%[![:space:]]*}"}"
    v="${v%"${v##*[![:space:]]}"}"
    # Strip quotes
    if [[ "$v" =~ ^\'(.*)\'$ ]] || [[ "$v" =~ ^\"(.*)\"$ ]]; then
        v="${BASH_REMATCH[1]}"
    fi
    # Lowercase (portable, no bash 4+ ${v,,})
    printf '%s' "$v" | tr '[:upper:]' '[:lower:]'
}

# Validate age-encrypt value and warn if unrecognized
# Args: raw_value
# Returns 0 if valid, 1 if invalid (with warning)
validate_age_encrypt_value() {
    local raw_value="$1"

    if [[ -z "$raw_value" ]]; then
        return 0  # Missing is OK (not an error, just means no encryption)
    fi

    local value
    value=$(normalize_yaml_value "$raw_value")

    case "$value" in
        yes|true|on|no|false|off)
            return 0
            ;;
        *)
            echo "md-age: WARNING: unrecognized age-encrypt value: $raw_value" >&2
            echo "md-age: Expected: yes/no/true/false/on/off" >&2
            return 1
            ;;
    esac
}

# Check if frontmatter indicates encryption is enabled
# Accepts YAML 1.1 booleans: yes/true/on (case-insensitive, with optional quotes)
# Returns 0 (success) if should encrypt, 1 otherwise
# Warns on unrecognized values
should_encrypt() {
    local input
    input=$(cat)

    # Extract age-encrypt value
    local raw_value
    raw_value=$(echo "$input" | grep -E "^age-encrypt:" | head -1 | sed 's/^age-encrypt:[[:space:]]*//')

    if [[ -z "$raw_value" ]]; then
        return 1
    fi

    # Validate and warn if needed
    if ! validate_age_encrypt_value "$raw_value"; then
        return 1
    fi

    local value
    value=$(normalize_yaml_value "$raw_value")

    # Check for YAML 1.1 boolean true values
    case "$value" in
        yes|true|on)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Parse frontmatter - sets global vars: FRONTMATTER and BODY
# Returns 1 if no frontmatter found
parse_frontmatter() {
    local content="$1"
    local line
    local in_fm=0
    local fm_done=0
    FRONTMATTER=""
    BODY=""

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ $in_fm -eq 0 ]] && [[ $fm_done -eq 0 ]]; then
            if [[ "$line" == "---" ]]; then
                in_fm=1
                FRONTMATTER="$line"$'\n'
            else
                # No frontmatter
                BODY="$content"
                return 1
            fi
        elif [[ $in_fm -eq 1 ]]; then
            FRONTMATTER+="$line"$'\n'
            if [[ "$line" == "---" ]]; then
                in_fm=0
                fm_done=1
            fi
        else
            BODY+="$line"$'\n'
        fi
    done <<< "$content"

    [[ -n "$FRONTMATTER" ]] || return 1
    return 0
}

# Extract age-recipients from frontmatter (one per line)
# Handles YAML variants: "- item", "  - item", "-item" (no space after dash)
extract_recipients() {
    awk '
    /^age-recipients:/ { in_recip = 1; next }
    in_recip && /^---$/ { exit }
    in_recip && /^[[:space:]]*-[[:space:]]*[^-]/ {
        sub(/^[[:space:]]*-[[:space:]]*/, "")
        if (length($0) > 0) print
        next
    }
    in_recip && /^[^[:space:]-]/ { exit }
    '
}

# Build recipient args for age from frontmatter recipients
# Args: recipients [base_dir]
# base_dir is used to resolve relative paths (default: current directory)
build_recipient_args() {
    local recipients="$1"
    local base_dir="${2:-.}"
    local args=""
    local git_root=""

    while IFS= read -r r; do
        [[ -z "$r" ]] && continue
        if [[ "$r" == age1* ]] || [[ "$r" == ssh-* ]]; then
            args="$args -r $r"
        elif [[ "$r" == git:* ]]; then
            # git: prefix - resolve from git repo root
            if [[ -z "$git_root" ]]; then
                git_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
                    echo "md-age: ERROR: git: prefix used but not in a git repository" >&2
                    return 1
                }
            fi
            local git_path="${r#git:}"
            args="$args -R $git_root/$git_path"
        else
            # Expand ~ for file paths
            local expanded="${r/#\~/$HOME}"
            # Resolve relative paths from base_dir
            if [[ "$expanded" != /* ]]; then
                expanded="$base_dir/$expanded"
            fi
            args="$args -R $expanded"
        fi
    done <<< "$recipients"
    echo "$args"
}

# Route to git subcommand if first arg is "git"
if [[ "${1:-}" == "git" ]]; then
    shift
    case "${1:-}" in
        init)   shift; git_init "$@" ;;
        config) shift; git_config "$@" ;;
        rekey)  shift; git_rekey "$@" ;;
        clean)  shift; git_clean "$@" ;;
        smudge) shift; git_smudge "$@" ;;
        -h|--help|"") git_usage 0 ;;
        *) die "unknown git command: $1" ;;
    esac
    exit 0
fi

# Main
mode="encrypt"
recipients=()
recipient_files=()
identities=()
output=""

while getopts "edr:R:i:o:h" opt; do
    case "$opt" in
        e) mode="encrypt" ;;
        d) mode="decrypt" ;;
        r) recipients+=("$OPTARG") ;;
        R) recipient_files+=("$OPTARG") ;;
        i) identities+=("$OPTARG") ;;
        o) output="$OPTARG" ;;
        h) usage 0 ;;
        *) usage 1 ;;
    esac
done
shift $((OPTIND - 1))

input="${1:--}"

# Read input, preserving trailing newlines
if [[ "$input" == "-" ]]; then
    content=$(cat; printf x)
    content="${content%x}"
else
    [[ -f "$input" ]] || die "file not found: $input"
    content=$(cat "$input"; printf x)
    content="${content%x}"
fi

# Parse frontmatter (sets FRONTMATTER and BODY globals)
if ! parse_frontmatter "$content"; then
    frontmatter=""
    body="$content"
else
    frontmatter="$FRONTMATTER"
    body="$BODY"
fi

# Remove trailing newline from body for clean output
body="${body%$'\n'}"

do_output() {
    if [[ -n "$output" ]]; then
        cat > "$output"
    else
        cat
    fi
}

if [[ "$mode" == "decrypt" ]]; then
    # Decryption
    [[ ${#identities[@]} -gt 0 ]] || die "no identity specified (-i)"

    # Build identity args
    id_args=""
    for id in "${identities[@]}"; do
        id_args="$id_args -i $id"
    done

    # Check if body looks encrypted
    if [[ "$body" != *"-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
        die "no encrypted content found"
    fi

    # Decrypt body
    decrypted=$(echo "$body" | $age_cmd -d $id_args) || die "decryption failed"

    # Output frontmatter + decrypted body
    {
        [[ -n "$frontmatter" ]] && printf '%s' "$frontmatter"
        printf '%s\n' "$decrypted"
    } | do_output

elif [[ "$mode" == "encrypt" ]]; then
    # Encryption

    # Build recipient args
    age_args=""

    # Use explicit recipients if provided
    if [[ ${#recipients[@]} -gt 0 ]] || [[ ${#recipient_files[@]} -gt 0 ]]; then
        for r in "${recipients[@]}"; do
            if [[ "$r" == age1* ]] || [[ "$r" == ssh-* ]]; then
                age_args="$age_args -r $r"
            else
                age_args="$age_args -R ${r/#\~/$HOME}"
            fi
        done
        for rf in "${recipient_files[@]}"; do
            age_args="$age_args -R ${rf/#\~/$HOME}"
        done
    elif [[ -n "$frontmatter" ]]; then
        # Validate age-encrypt value if present (warn on typos)
        age_encrypt_val=$(echo "$frontmatter" | grep -E "^age-encrypt:" | head -1 | sed 's/^age-encrypt:[[:space:]]*//')
        if [[ -n "$age_encrypt_val" ]]; then
            validate_age_encrypt_value "$age_encrypt_val" || die "fix the age-encrypt value and retry"
        fi
        # Extract from frontmatter
        fm_recipients=$(echo "$frontmatter" | extract_recipients)
        [[ -n "$fm_recipients" ]] || die "no recipients specified and none in frontmatter"
        # Resolve relative paths from input file's directory
        input_dir="."
        [[ "$input" != "-" ]] && input_dir=$(dirname "$input")
        age_args=$(build_recipient_args "$fm_recipients" "$input_dir")
    else
        die "no recipients specified (-r) and no frontmatter"
    fi

    # Encrypt body (always armored for markdown embedding)
    encrypted=$(echo "$body" | $age_cmd -e -a $age_args) || die "encryption failed"

    # Build output
    if [[ -n "$frontmatter" ]]; then
        # Use existing frontmatter
        {
            printf '%s' "$frontmatter"
            printf '%s\n' "$encrypted"
        } | do_output
    else
        # Create minimal frontmatter
        {
            echo "---"
            echo "age-encrypt: yes"
            echo "age-recipients:"
            for r in "${recipients[@]}"; do
                echo "  - $r"
            done
            for rf in "${recipient_files[@]}"; do
                echo "  - $rf"
            done
            echo "---"
            printf '%s\n' "$encrypted"
        } | do_output
    fi
fi
