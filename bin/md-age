#!/usr/bin/env bash
#
# md-age - age encryption for markdown files with YAML frontmatter
#
# Encrypts/decrypts markdown files while preserving frontmatter.
# Recipients are read from frontmatter age-recipients field by default.
#
# SPDX-License-Identifier: AGPL-3.0-or-later

set -euo pipefail

usage() {
    cat <<'EOF'
Usage: md-age [-e|-d] [-r RECIPIENT]... [-i IDENTITY]... [-o OUTPUT] [FILE]

Encrypt or decrypt markdown files with age, preserving YAML frontmatter.

Modes:
  -e            Encrypt (default)
  -d            Decrypt

Options:
  -r RECIPIENT  Recipient for encryption (age public key, SSH key, or file path)
                If not specified, uses age-recipients from frontmatter
  -R FILE       Recipients file (passed to age as -R)
  -i IDENTITY   Identity file for decryption (passed to age as -i)
  -o OUTPUT     Write to OUTPUT instead of stdout
  -h            Show this help

Examples:
  # Encrypt using recipients from frontmatter
  md-age -e notes.md > notes.md.enc

  # Encrypt with explicit recipient
  md-age -e -r age1... plaintext.md > encrypted.md

  # Decrypt
  md-age -d -i ~/.age/key.txt encrypted.md > decrypted.md

  # In-place edit (decrypt, edit, re-encrypt)
  md-age -d -i key.txt file.md | vim - | md-age -e -o file.md

Git integration:
  md-age git init              Set up filters in current repo
  md-age git config add -i     Add identity for decryption
  md-age git config list       Show configured identities
  md-age git config remove -i  Remove identity

  Run 'md-age git --help' for more details.

Frontmatter format:
  ---
  age-encrypt: yes
  age-recipients:
    - age1...        # age public key
    - ssh-ed25519... # SSH public key
    - ~/.age/file    # recipients file path
  ---
EOF
    exit "${1:-0}"
}

git_usage() {
    cat <<'EOF'
Usage: md-age git <command> [options]

git subcommands for transparent encryption:
  init              Set up filters in current repo
  config            Manage identity configuration
  clean             Encrypt filter (for git)
  smudge            Decrypt filter (for git)

Run 'md-age git <command> --help' for command-specific help.
EOF
    exit "${1:-0}"
}

# Compute cache key for content
# Key = SHA256(sorted_recipients || NUL || body)
compute_cache_key() {
    local recipients="$1"
    local body="$2"

    # Sort recipients for consistency
    local sorted_recipients
    sorted_recipients=$(echo "$recipients" | sort)

    # Compute hash
    printf '%s\0%s' "$sorted_recipients" "$body" | shasum -a 256 | cut -d' ' -f1
}

# Get cache directory (creates if needed)
get_cache_dir() {
    local git_dir
    git_dir=$(git rev-parse --git-dir 2>/dev/null) || return 1
    local cache_dir="$git_dir/md-age/hashes"
    mkdir -p "$cache_dir"
    echo "$cache_dir"
}

# Get cached ciphertext for key, returns 1 if not found
get_cached() {
    local key="$1"
    local cache_dir
    cache_dir=$(get_cache_dir) || return 1

    local prefix="${key:0:2}"
    local cache_file="$cache_dir/$prefix/$key"

    if [[ -f "$cache_file" ]]; then
        cat "$cache_file"
        return 0
    fi
    return 1
}

# Store ciphertext in cache
set_cached() {
    local key="$1"
    local ciphertext="$2"
    local cache_dir
    cache_dir=$(get_cache_dir) || return 1

    local prefix="${key:0:2}"
    mkdir -p "$cache_dir/$prefix"
    local cache_file="$cache_dir/$prefix/$key"

    printf '%s' "$ciphertext" > "$cache_file"
}

git_init() {
    if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git init

Set up md-age filter configuration in the current git repository.
Adds filter and diff settings to .git/config.

After running this, add to your .gitattributes:
  *.md filter=md-age diff=md-age
EOF
        exit 0
    fi

    # Check we're in a git repo
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    # Set up filter
    git config filter.md-age.clean "md-age git clean %f"
    git config filter.md-age.smudge "md-age git smudge %f"
    git config filter.md-age.required true

    # Set up diff
    git config diff.md-age.textconv "md-age git smudge"

    echo "md-age: filter configured in .git/config"
    echo "md-age: add '*.md filter=md-age diff=md-age' to .gitattributes"
}
git_config() {
    local cmd="${1:-}"

    case "$cmd" in
        -h|--help|"")
            cat <<'EOF'
Usage: md-age git config <command>

Commands:
  add -i <path>     Add an identity file
  list              List configured identities
  remove -i <path>  Remove an identity file

Identities are stored in .git/config (not version controlled).
EOF
            exit 0
            ;;
        add)
            shift
            git_config_add "$@"
            ;;
        list)
            git_config_list
            ;;
        remove)
            shift
            git_config_remove "$@"
            ;;
        *)
            die "unknown config command: $cmd"
            ;;
    esac
}

git_config_add() {
    local identity=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i) identity="$2"; shift 2 ;;
            *) die "unknown option: $1" ;;
        esac
    done

    [[ -n "$identity" ]] || die "no identity specified (-i)"
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    # Expand ~ but store the expanded path
    local expanded="${identity/#\~/$HOME}"

    # Check if already added
    if git config --get-all md-age.config.identity 2>/dev/null | grep -qF "$expanded"; then
        echo "md-age: identity already configured: $expanded"
        return 0
    fi

    git config --add md-age.config.identity "$expanded"
    echo "md-age: added identity: $expanded"
}

git_config_list() {
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    local identities
    identities=$(git config --get-all md-age.config.identity 2>/dev/null || true)

    if [[ -z "$identities" ]]; then
        echo "md-age: no identities configured"
        echo "md-age: use 'md-age git config add -i <path>' to add one"
        return 0
    fi

    echo "Identities:"
    while IFS= read -r id; do
        echo "  $id"
    done <<< "$identities"
}

git_config_remove() {
    local identity=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i) identity="$2"; shift 2 ;;
            *) die "unknown option: $1" ;;
        esac
    done

    [[ -n "$identity" ]] || die "no identity specified (-i)"
    git rev-parse --git-dir >/dev/null 2>&1 || die "not in a git repository"

    local expanded="${identity/#\~/$HOME}"

    if git config --unset md-age.config.identity "$expanded" 2>/dev/null; then
        echo "md-age: removed identity: $expanded"
    else
        die "identity not found: $expanded"
    fi
}
git_clean() {
    local filename="${1:-}"

    if [[ "$filename" == "-h" ]] || [[ "$filename" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git clean <filename>

Git clean filter - encrypts md-age files on stage.
Reads from stdin, writes to stdout.
Non-md-age files pass through unchanged.
EOF
        exit 0
    fi

    # Read all stdin
    local content
    content=$(cat)

    # Parse frontmatter
    if ! parse_frontmatter "$content"; then
        # No frontmatter - pass through
        printf '%s' "$content"
        return 0
    fi

    local frontmatter="$FRONTMATTER"
    local body="$BODY"
    body="${body%$'\n'}"  # Remove trailing newline

    # Check if this is an md-age file
    if ! echo "$frontmatter" | grep -q '^age-encrypt: yes'; then
        # Not an md-age file - pass through
        printf '%s' "$content"
        return 0
    fi

    # Extract recipients
    local recipients
    recipients=$(echo "$frontmatter" | extract_recipients)

    if [[ -z "$recipients" ]]; then
        echo "md-age: clean: no recipients in frontmatter for $filename" >&2
        exit 1
    fi

    # Compute cache key
    local cache_key
    cache_key=$(compute_cache_key "$recipients" "$body")

    # Check cache
    local encrypted
    if encrypted=$(get_cached "$cache_key" 2>/dev/null); then
        # Cache hit - use cached ciphertext
        printf '%s' "$frontmatter"
        printf '%s\n' "$encrypted"
        return 0
    fi

    # Cache miss - encrypt
    local age_args
    age_args=$(build_recipient_args "$recipients")

    encrypted=$(printf '%s' "$body" | $age_cmd -e -a $age_args) || {
        echo "md-age: clean: encryption failed for $filename" >&2
        exit 1
    }

    # Store in cache
    set_cached "$cache_key" "$encrypted" 2>/dev/null || true

    # Output frontmatter + encrypted body
    printf '%s' "$frontmatter"
    printf '%s\n' "$encrypted"
}
git_smudge() {
    local filename="${1:-}"

    if [[ "$filename" == "-h" ]] || [[ "$filename" == "--help" ]]; then
        cat <<'EOF'
Usage: md-age git smudge <filename>

Git smudge filter - decrypts md-age files on checkout.
Reads from stdin, writes to stdout.
Non-md-age files pass through unchanged.
If no identity configured, encrypted files pass through unchanged.
EOF
        exit 0
    fi

    # Read all stdin
    local content
    content=$(cat)

    # Parse frontmatter
    if ! parse_frontmatter "$content"; then
        # No frontmatter - pass through
        printf '%s' "$content"
        return 0
    fi

    local frontmatter="$FRONTMATTER"
    local body="$BODY"
    body="${body%$'\n'}"

    # Check if this is an md-age file
    if ! echo "$frontmatter" | grep -q '^age-encrypt: yes'; then
        printf '%s' "$content"
        return 0
    fi

    # Check if body is encrypted
    if [[ "$body" != *"-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
        # Not encrypted - pass through (new file perhaps)
        printf '%s' "$content"
        return 0
    fi

    # Get identities from git config
    local identities
    identities=$(git config --get-all md-age.config.identity 2>/dev/null || true)

    if [[ -z "$identities" ]]; then
        # No identity - pass through encrypted
        printf '%s' "$content"
        return 0
    fi

    # Build identity args
    local id_args=""
    while IFS= read -r id; do
        [[ -z "$id" ]] && continue
        id_args="$id_args -i $id"
    done <<< "$identities"

    # Try to decrypt
    local decrypted
    if decrypted=$(printf '%s' "$body" | $age_cmd -d $id_args 2>/dev/null); then
        # Success - output frontmatter + decrypted
        printf '%s' "$frontmatter"
        printf '%s\n' "$decrypted"
    else
        # Decrypt failed - pass through encrypted
        printf '%s' "$content"
    fi
}

die() {
    echo "md-age: $*" >&2
    exit 1
}

# Set age command early (needed by git subcommands)
age_cmd="${MD_AGE_COMMAND:-age}"

# Parse frontmatter - sets global vars: FRONTMATTER and BODY
# Returns 1 if no frontmatter found
parse_frontmatter() {
    local content="$1"
    local line
    local in_fm=0
    local fm_done=0
    FRONTMATTER=""
    BODY=""

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ $in_fm -eq 0 ]] && [[ $fm_done -eq 0 ]]; then
            if [[ "$line" == "---" ]]; then
                in_fm=1
                FRONTMATTER="$line"$'\n'
            else
                # No frontmatter
                BODY="$content"
                return 1
            fi
        elif [[ $in_fm -eq 1 ]]; then
            FRONTMATTER+="$line"$'\n'
            if [[ "$line" == "---" ]]; then
                in_fm=0
                fm_done=1
            fi
        else
            BODY+="$line"$'\n'
        fi
    done <<< "$content"

    [[ -n "$FRONTMATTER" ]] || return 1
    return 0
}

# Extract age-recipients from frontmatter (one per line)
extract_recipients() {
    awk '
    /^age-recipients:/ { in_recip = 1; next }
    in_recip && /^[[:space:]]+-[[:space:]]+/ {
        sub(/^[[:space:]]+-[[:space:]]+/, "")
        print
        next
    }
    in_recip && /^[^[:space:]]/ { exit }
    '
}

# Build recipient args for age from frontmatter recipients
build_recipient_args() {
    local recipients="$1"
    local args=""
    while IFS= read -r r; do
        [[ -z "$r" ]] && continue
        if [[ "$r" == age1* ]] || [[ "$r" == ssh-* ]]; then
            args="$args -r $r"
        else
            # Expand ~ for file paths
            local expanded="${r/#\~/$HOME}"
            args="$args -R $expanded"
        fi
    done <<< "$recipients"
    echo "$args"
}

# Route to git subcommand if first arg is "git"
if [[ "${1:-}" == "git" ]]; then
    shift
    case "${1:-}" in
        init)   shift; git_init "$@" ;;
        config) shift; git_config "$@" ;;
        clean)  shift; git_clean "$@" ;;
        smudge) shift; git_smudge "$@" ;;
        -h|--help|"") git_usage 0 ;;
        *) die "unknown git command: $1" ;;
    esac
    exit 0
fi

# Main
mode="encrypt"
recipients=()
recipient_files=()
identities=()
output=""

while getopts "edr:R:i:o:h" opt; do
    case "$opt" in
        e) mode="encrypt" ;;
        d) mode="decrypt" ;;
        r) recipients+=("$OPTARG") ;;
        R) recipient_files+=("$OPTARG") ;;
        i) identities+=("$OPTARG") ;;
        o) output="$OPTARG" ;;
        h) usage 0 ;;
        *) usage 1 ;;
    esac
done
shift $((OPTIND - 1))

input="${1:--}"

# Read input
if [[ "$input" == "-" ]]; then
    content=$(cat)
else
    [[ -f "$input" ]] || die "file not found: $input"
    content=$(cat "$input")
fi

# Parse frontmatter (sets FRONTMATTER and BODY globals)
if ! parse_frontmatter "$content"; then
    frontmatter=""
    body="$content"
else
    frontmatter="$FRONTMATTER"
    body="$BODY"
fi

# Remove trailing newline from body for clean output
body="${body%$'\n'}"

do_output() {
    if [[ -n "$output" ]]; then
        cat > "$output"
    else
        cat
    fi
}

if [[ "$mode" == "decrypt" ]]; then
    # Decryption
    [[ ${#identities[@]} -gt 0 ]] || die "no identity specified (-i)"

    # Build identity args
    id_args=""
    for id in "${identities[@]}"; do
        id_args="$id_args -i $id"
    done

    # Check if body looks encrypted
    if [[ "$body" != *"-----BEGIN AGE ENCRYPTED FILE-----"* ]]; then
        die "no encrypted content found"
    fi

    # Decrypt body
    decrypted=$(echo "$body" | $age_cmd -d $id_args) || die "decryption failed"

    # Output frontmatter + decrypted body
    {
        [[ -n "$frontmatter" ]] && printf '%s' "$frontmatter"
        printf '%s\n' "$decrypted"
    } | do_output

elif [[ "$mode" == "encrypt" ]]; then
    # Encryption

    # Build recipient args
    age_args=""

    # Use explicit recipients if provided
    if [[ ${#recipients[@]} -gt 0 ]] || [[ ${#recipient_files[@]} -gt 0 ]]; then
        for r in "${recipients[@]}"; do
            if [[ "$r" == age1* ]] || [[ "$r" == ssh-* ]]; then
                age_args="$age_args -r $r"
            else
                age_args="$age_args -R ${r/#\~/$HOME}"
            fi
        done
        for rf in "${recipient_files[@]}"; do
            age_args="$age_args -R ${rf/#\~/$HOME}"
        done
    elif [[ -n "$frontmatter" ]]; then
        # Extract from frontmatter
        fm_recipients=$(echo "$frontmatter" | extract_recipients)
        [[ -n "$fm_recipients" ]] || die "no recipients specified and none in frontmatter"
        age_args=$(build_recipient_args "$fm_recipients")
    else
        die "no recipients specified (-r) and no frontmatter"
    fi

    # Encrypt body (always armored for markdown embedding)
    encrypted=$(echo "$body" | $age_cmd -e -a $age_args) || die "encryption failed"

    # Build output
    if [[ -n "$frontmatter" ]]; then
        # Use existing frontmatter
        {
            printf '%s' "$frontmatter"
            printf '%s\n' "$encrypted"
        } | do_output
    else
        # Create minimal frontmatter
        {
            echo "---"
            echo "age-encrypt: yes"
            echo "age-recipients:"
            for r in "${recipients[@]}"; do
                echo "  - $r"
            done
            for rf in "${recipient_files[@]}"; do
                echo "  - $rf"
            done
            echo "---"
            printf '%s\n' "$encrypted"
        } | do_output
    fi
fi
